// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 31.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `alkanes.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:alkanes.uint128)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Uint128 {
    // message fields
    // @@protoc_insertion_point(field:alkanes.uint128.lo)
    pub lo: u64,
    // @@protoc_insertion_point(field:alkanes.uint128.hi)
    pub hi: u64,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.uint128.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Uint128 {
    fn default() -> &'a Uint128 {
        <Uint128 as ::protobuf::Message>::default_instance()
    }
}

impl Uint128 {
    pub fn new() -> Uint128 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lo",
            |m: &Uint128| { &m.lo },
            |m: &mut Uint128| { &mut m.lo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hi",
            |m: &Uint128| { &m.hi },
            |m: &mut Uint128| { &mut m.hi },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Uint128>(
            "uint128",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Uint128 {
    const NAME: &'static str = "uint128";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lo = is.read_uint64()?;
                },
                16 => {
                    self.hi = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.lo != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.lo);
        }
        if self.hi != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.hi);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.lo != 0 {
            os.write_uint64(1, self.lo)?;
        }
        if self.hi != 0 {
            os.write_uint64(2, self.hi)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Uint128 {
        Uint128::new()
    }

    fn clear(&mut self) {
        self.lo = 0;
        self.hi = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Uint128 {
        static instance: Uint128 = Uint128 {
            lo: 0,
            hi: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Uint128 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("uint128").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Uint128 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint128 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneId {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneId.block)
    pub block: ::protobuf::MessageField<Uint128>,
    // @@protoc_insertion_point(field:alkanes.AlkaneId.tx)
    pub tx: ::protobuf::MessageField<Uint128>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneId {
    fn default() -> &'a AlkaneId {
        <AlkaneId as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneId {
    pub fn new() -> AlkaneId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Uint128>(
            "block",
            |m: &AlkaneId| { &m.block },
            |m: &mut AlkaneId| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Uint128>(
            "tx",
            |m: &AlkaneId| { &m.tx },
            |m: &mut AlkaneId| { &mut m.tx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneId>(
            "AlkaneId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneId {
    const NAME: &'static str = "AlkaneId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tx)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tx.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneId {
        AlkaneId::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.tx.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneId {
        static instance: AlkaneId = AlkaneId {
            block: ::protobuf::MessageField::none(),
            tx: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneTransfer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneTransfer {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneTransfer.id)
    pub id: ::protobuf::MessageField<AlkaneId>,
    // @@protoc_insertion_point(field:alkanes.AlkaneTransfer.value)
    pub value: ::protobuf::MessageField<Uint128>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneTransfer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneTransfer {
    fn default() -> &'a AlkaneTransfer {
        <AlkaneTransfer as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneTransfer {
    pub fn new() -> AlkaneTransfer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "id",
            |m: &AlkaneTransfer| { &m.id },
            |m: &mut AlkaneTransfer| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Uint128>(
            "value",
            |m: &AlkaneTransfer| { &m.value },
            |m: &mut AlkaneTransfer| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneTransfer>(
            "AlkaneTransfer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneTransfer {
    const NAME: &'static str = "AlkaneTransfer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneTransfer {
        AlkaneTransfer::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneTransfer {
        static instance: AlkaneTransfer = AlkaneTransfer {
            id: ::protobuf::MessageField::none(),
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneTransfer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneTransfer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneTransfer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.MultiSimulateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiSimulateRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.MultiSimulateRequest.parcels)
    pub parcels: ::std::vec::Vec<MessageContextParcel>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.MultiSimulateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiSimulateRequest {
    fn default() -> &'a MultiSimulateRequest {
        <MultiSimulateRequest as ::protobuf::Message>::default_instance()
    }
}

impl MultiSimulateRequest {
    pub fn new() -> MultiSimulateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parcels",
            |m: &MultiSimulateRequest| { &m.parcels },
            |m: &mut MultiSimulateRequest| { &mut m.parcels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiSimulateRequest>(
            "MultiSimulateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiSimulateRequest {
    const NAME: &'static str = "MultiSimulateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.parcels.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.parcels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.parcels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiSimulateRequest {
        MultiSimulateRequest::new()
    }

    fn clear(&mut self) {
        self.parcels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiSimulateRequest {
        static instance: MultiSimulateRequest = MultiSimulateRequest {
            parcels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiSimulateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiSimulateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiSimulateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiSimulateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.MessageContextParcel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageContextParcel {
    // message fields
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.alkanes)
    pub alkanes: ::std::vec::Vec<AlkaneTransfer>,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.transaction)
    pub transaction: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.block)
    pub block: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.height)
    pub height: u64,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.txindex)
    pub txindex: u32,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.calldata)
    pub calldata: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.vout)
    pub vout: u32,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.pointer)
    pub pointer: u32,
    // @@protoc_insertion_point(field:alkanes.MessageContextParcel.refund_pointer)
    pub refund_pointer: u32,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.MessageContextParcel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageContextParcel {
    fn default() -> &'a MessageContextParcel {
        <MessageContextParcel as ::protobuf::Message>::default_instance()
    }
}

impl MessageContextParcel {
    pub fn new() -> MessageContextParcel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alkanes",
            |m: &MessageContextParcel| { &m.alkanes },
            |m: &mut MessageContextParcel| { &mut m.alkanes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction",
            |m: &MessageContextParcel| { &m.transaction },
            |m: &mut MessageContextParcel| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block",
            |m: &MessageContextParcel| { &m.block },
            |m: &mut MessageContextParcel| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &MessageContextParcel| { &m.height },
            |m: &mut MessageContextParcel| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txindex",
            |m: &MessageContextParcel| { &m.txindex },
            |m: &mut MessageContextParcel| { &mut m.txindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "calldata",
            |m: &MessageContextParcel| { &m.calldata },
            |m: &mut MessageContextParcel| { &mut m.calldata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vout",
            |m: &MessageContextParcel| { &m.vout },
            |m: &mut MessageContextParcel| { &mut m.vout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pointer",
            |m: &MessageContextParcel| { &m.pointer },
            |m: &mut MessageContextParcel| { &mut m.pointer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refund_pointer",
            |m: &MessageContextParcel| { &m.refund_pointer },
            |m: &mut MessageContextParcel| { &mut m.refund_pointer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageContextParcel>(
            "MessageContextParcel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageContextParcel {
    const NAME: &'static str = "MessageContextParcel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.alkanes.push(is.read_message()?);
                },
                18 => {
                    self.transaction = is.read_bytes()?;
                },
                26 => {
                    self.block = is.read_bytes()?;
                },
                32 => {
                    self.height = is.read_uint64()?;
                },
                48 => {
                    self.txindex = is.read_uint32()?;
                },
                42 => {
                    self.calldata = is.read_bytes()?;
                },
                56 => {
                    self.vout = is.read_uint32()?;
                },
                64 => {
                    self.pointer = is.read_uint32()?;
                },
                72 => {
                    self.refund_pointer = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.alkanes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.transaction);
        }
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.block);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.height);
        }
        if self.txindex != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.txindex);
        }
        if !self.calldata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.calldata);
        }
        if self.vout != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.vout);
        }
        if self.pointer != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.pointer);
        }
        if self.refund_pointer != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.refund_pointer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.alkanes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.transaction.is_empty() {
            os.write_bytes(2, &self.transaction)?;
        }
        if !self.block.is_empty() {
            os.write_bytes(3, &self.block)?;
        }
        if self.height != 0 {
            os.write_uint64(4, self.height)?;
        }
        if self.txindex != 0 {
            os.write_uint32(6, self.txindex)?;
        }
        if !self.calldata.is_empty() {
            os.write_bytes(5, &self.calldata)?;
        }
        if self.vout != 0 {
            os.write_uint32(7, self.vout)?;
        }
        if self.pointer != 0 {
            os.write_uint32(8, self.pointer)?;
        }
        if self.refund_pointer != 0 {
            os.write_uint32(9, self.refund_pointer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageContextParcel {
        MessageContextParcel::new()
    }

    fn clear(&mut self) {
        self.alkanes.clear();
        self.transaction.clear();
        self.block.clear();
        self.height = 0;
        self.txindex = 0;
        self.calldata.clear();
        self.vout = 0;
        self.pointer = 0;
        self.refund_pointer = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageContextParcel {
        static instance: MessageContextParcel = MessageContextParcel {
            alkanes: ::std::vec::Vec::new(),
            transaction: ::std::vec::Vec::new(),
            block: ::std::vec::Vec::new(),
            height: 0,
            txindex: 0,
            calldata: ::std::vec::Vec::new(),
            vout: 0,
            pointer: 0,
            refund_pointer: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageContextParcel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageContextParcel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageContextParcel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageContextParcel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.KeyValuePair)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyValuePair {
    // message fields
    // @@protoc_insertion_point(field:alkanes.KeyValuePair.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.KeyValuePair.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.KeyValuePair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyValuePair {
    fn default() -> &'a KeyValuePair {
        <KeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePair {
    pub fn new() -> KeyValuePair {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KeyValuePair| { &m.key },
            |m: &mut KeyValuePair| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &KeyValuePair| { &m.value },
            |m: &mut KeyValuePair| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValuePair>(
            "KeyValuePair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyValuePair {
    const NAME: &'static str = "KeyValuePair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyValuePair {
        KeyValuePair::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyValuePair {
        static instance: KeyValuePair = KeyValuePair {
            key: ::std::vec::Vec::new(),
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyValuePair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyValuePair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.ExtendedCallResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExtendedCallResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.ExtendedCallResponse.alkanes)
    pub alkanes: ::std::vec::Vec<AlkaneTransfer>,
    // @@protoc_insertion_point(field:alkanes.ExtendedCallResponse.storage)
    pub storage: ::std::vec::Vec<KeyValuePair>,
    // @@protoc_insertion_point(field:alkanes.ExtendedCallResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.ExtendedCallResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtendedCallResponse {
    fn default() -> &'a ExtendedCallResponse {
        <ExtendedCallResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExtendedCallResponse {
    pub fn new() -> ExtendedCallResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alkanes",
            |m: &ExtendedCallResponse| { &m.alkanes },
            |m: &mut ExtendedCallResponse| { &mut m.alkanes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storage",
            |m: &ExtendedCallResponse| { &m.storage },
            |m: &mut ExtendedCallResponse| { &mut m.storage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ExtendedCallResponse| { &m.data },
            |m: &mut ExtendedCallResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtendedCallResponse>(
            "ExtendedCallResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExtendedCallResponse {
    const NAME: &'static str = "ExtendedCallResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.alkanes.push(is.read_message()?);
                },
                18 => {
                    self.storage.push(is.read_message()?);
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.alkanes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.storage {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.alkanes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.storage {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtendedCallResponse {
        ExtendedCallResponse::new()
    }

    fn clear(&mut self) {
        self.alkanes.clear();
        self.storage.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtendedCallResponse {
        static instance: ExtendedCallResponse = ExtendedCallResponse {
            alkanes: ::std::vec::Vec::new(),
            storage: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExtendedCallResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtendedCallResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtendedCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendedCallResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.Context)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Context {
    // message fields
    // @@protoc_insertion_point(field:alkanes.Context.myself)
    pub myself: ::protobuf::MessageField<AlkaneId>,
    // @@protoc_insertion_point(field:alkanes.Context.caller)
    pub caller: ::protobuf::MessageField<AlkaneId>,
    // @@protoc_insertion_point(field:alkanes.Context.inputs)
    pub inputs: ::std::vec::Vec<Uint128>,
    // @@protoc_insertion_point(field:alkanes.Context.vout)
    pub vout: u32,
    // @@protoc_insertion_point(field:alkanes.Context.incoming_alkanes)
    pub incoming_alkanes: ::std::vec::Vec<AlkaneTransfer>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.Context.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Context {
    fn default() -> &'a Context {
        <Context as ::protobuf::Message>::default_instance()
    }
}

impl Context {
    pub fn new() -> Context {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "myself",
            |m: &Context| { &m.myself },
            |m: &mut Context| { &mut m.myself },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "caller",
            |m: &Context| { &m.caller },
            |m: &mut Context| { &mut m.caller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &Context| { &m.inputs },
            |m: &mut Context| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vout",
            |m: &Context| { &m.vout },
            |m: &mut Context| { &mut m.vout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "incoming_alkanes",
            |m: &Context| { &m.incoming_alkanes },
            |m: &mut Context| { &mut m.incoming_alkanes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Context>(
            "Context",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Context {
    const NAME: &'static str = "Context";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.myself)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.caller)?;
                },
                26 => {
                    self.inputs.push(is.read_message()?);
                },
                32 => {
                    self.vout = is.read_uint32()?;
                },
                42 => {
                    self.incoming_alkanes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.myself.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.caller.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.vout != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.vout);
        }
        for value in &self.incoming_alkanes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.myself.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.caller.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.vout != 0 {
            os.write_uint32(4, self.vout)?;
        }
        for v in &self.incoming_alkanes {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Context {
        Context::new()
    }

    fn clear(&mut self) {
        self.myself.clear();
        self.caller.clear();
        self.inputs.clear();
        self.vout = 0;
        self.incoming_alkanes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Context {
        static instance: Context = Context {
            myself: ::protobuf::MessageField::none(),
            caller: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            vout: 0,
            incoming_alkanes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Context {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Context").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Context {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Context {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.TraceContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TraceContext {
    // message fields
    // @@protoc_insertion_point(field:alkanes.TraceContext.inner)
    pub inner: ::protobuf::MessageField<Context>,
    // @@protoc_insertion_point(field:alkanes.TraceContext.fuel)
    pub fuel: u64,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.TraceContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TraceContext {
    fn default() -> &'a TraceContext {
        <TraceContext as ::protobuf::Message>::default_instance()
    }
}

impl TraceContext {
    pub fn new() -> TraceContext {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Context>(
            "inner",
            |m: &TraceContext| { &m.inner },
            |m: &mut TraceContext| { &mut m.inner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fuel",
            |m: &TraceContext| { &m.fuel },
            |m: &mut TraceContext| { &mut m.fuel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TraceContext>(
            "TraceContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TraceContext {
    const NAME: &'static str = "TraceContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inner)?;
                },
                16 => {
                    self.fuel = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.fuel != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.fuel);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.fuel != 0 {
            os.write_uint64(2, self.fuel)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TraceContext {
        TraceContext::new()
    }

    fn clear(&mut self) {
        self.inner.clear();
        self.fuel = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TraceContext {
        static instance: TraceContext = TraceContext {
            inner: ::protobuf::MessageField::none(),
            fuel: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TraceContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TraceContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TraceContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TraceContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkanesEnterContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkanesEnterContext {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkanesEnterContext.call_type)
    pub call_type: ::protobuf::EnumOrUnknown<AlkanesTraceCallType>,
    // @@protoc_insertion_point(field:alkanes.AlkanesEnterContext.context)
    pub context: ::protobuf::MessageField<TraceContext>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkanesEnterContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkanesEnterContext {
    fn default() -> &'a AlkanesEnterContext {
        <AlkanesEnterContext as ::protobuf::Message>::default_instance()
    }
}

impl AlkanesEnterContext {
    pub fn new() -> AlkanesEnterContext {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "call_type",
            |m: &AlkanesEnterContext| { &m.call_type },
            |m: &mut AlkanesEnterContext| { &mut m.call_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TraceContext>(
            "context",
            |m: &AlkanesEnterContext| { &m.context },
            |m: &mut AlkanesEnterContext| { &mut m.context },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkanesEnterContext>(
            "AlkanesEnterContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkanesEnterContext {
    const NAME: &'static str = "AlkanesEnterContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.call_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.call_type != ::protobuf::EnumOrUnknown::new(AlkanesTraceCallType::NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.call_type.value());
        }
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.call_type != ::protobuf::EnumOrUnknown::new(AlkanesTraceCallType::NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.call_type))?;
        }
        if let Some(v) = self.context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkanesEnterContext {
        AlkanesEnterContext::new()
    }

    fn clear(&mut self) {
        self.call_type = ::protobuf::EnumOrUnknown::new(AlkanesTraceCallType::NONE);
        self.context.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkanesEnterContext {
        static instance: AlkanesEnterContext = AlkanesEnterContext {
            call_type: ::protobuf::EnumOrUnknown::from_i32(0),
            context: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkanesEnterContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkanesEnterContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkanesEnterContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkanesEnterContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkanesExitContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkanesExitContext {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkanesExitContext.status)
    pub status: ::protobuf::EnumOrUnknown<AlkanesTraceStatusFlag>,
    // @@protoc_insertion_point(field:alkanes.AlkanesExitContext.response)
    pub response: ::protobuf::MessageField<ExtendedCallResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkanesExitContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkanesExitContext {
    fn default() -> &'a AlkanesExitContext {
        <AlkanesExitContext as ::protobuf::Message>::default_instance()
    }
}

impl AlkanesExitContext {
    pub fn new() -> AlkanesExitContext {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &AlkanesExitContext| { &m.status },
            |m: &mut AlkanesExitContext| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExtendedCallResponse>(
            "response",
            |m: &AlkanesExitContext| { &m.response },
            |m: &mut AlkanesExitContext| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkanesExitContext>(
            "AlkanesExitContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkanesExitContext {
    const NAME: &'static str = "AlkanesExitContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != ::protobuf::EnumOrUnknown::new(AlkanesTraceStatusFlag::SUCCESS) {
            my_size += ::protobuf::rt::int32_size(1, self.status.value());
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != ::protobuf::EnumOrUnknown::new(AlkanesTraceStatusFlag::SUCCESS) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkanesExitContext {
        AlkanesExitContext::new()
    }

    fn clear(&mut self) {
        self.status = ::protobuf::EnumOrUnknown::new(AlkanesTraceStatusFlag::SUCCESS);
        self.response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkanesExitContext {
        static instance: AlkanesExitContext = AlkanesExitContext {
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkanesExitContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkanesExitContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkanesExitContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkanesExitContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkanesCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkanesCreate {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkanesCreate.new_alkane)
    pub new_alkane: ::protobuf::MessageField<AlkaneId>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkanesCreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkanesCreate {
    fn default() -> &'a AlkanesCreate {
        <AlkanesCreate as ::protobuf::Message>::default_instance()
    }
}

impl AlkanesCreate {
    pub fn new() -> AlkanesCreate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "new_alkane",
            |m: &AlkanesCreate| { &m.new_alkane },
            |m: &mut AlkanesCreate| { &mut m.new_alkane },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkanesCreate>(
            "AlkanesCreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkanesCreate {
    const NAME: &'static str = "AlkanesCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_alkane)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_alkane.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_alkane.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkanesCreate {
        AlkanesCreate::new()
    }

    fn clear(&mut self) {
        self.new_alkane.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkanesCreate {
        static instance: AlkanesCreate = AlkanesCreate {
            new_alkane: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkanesCreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkanesCreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkanesCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkanesCreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkanesTraceEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkanesTraceEvent {
    // message oneof groups
    pub event: ::std::option::Option<alkanes_trace_event::Event>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkanesTraceEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkanesTraceEvent {
    fn default() -> &'a AlkanesTraceEvent {
        <AlkanesTraceEvent as ::protobuf::Message>::default_instance()
    }
}

impl AlkanesTraceEvent {
    pub fn new() -> AlkanesTraceEvent {
        ::std::default::Default::default()
    }

    // .alkanes.AlkanesEnterContext enter_context = 1;

    pub fn enter_context(&self) -> &AlkanesEnterContext {
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(ref v)) => v,
            _ => <AlkanesEnterContext as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_enter_context(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_enter_context(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enter_context(&mut self, v: AlkanesEnterContext) {
        self.event = ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enter_context(&mut self) -> &mut AlkanesEnterContext {
        if let ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(AlkanesEnterContext::new()));
        }
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enter_context(&mut self) -> AlkanesEnterContext {
        if self.has_enter_context() {
            match self.event.take() {
                ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(v)) => v,
                _ => panic!(),
            }
        } else {
            AlkanesEnterContext::new()
        }
    }

    // .alkanes.AlkanesExitContext exit_context = 2;

    pub fn exit_context(&self) -> &AlkanesExitContext {
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(ref v)) => v,
            _ => <AlkanesExitContext as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_exit_context(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_exit_context(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exit_context(&mut self, v: AlkanesExitContext) {
        self.event = ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exit_context(&mut self) -> &mut AlkanesExitContext {
        if let ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(AlkanesExitContext::new()));
        }
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exit_context(&mut self) -> AlkanesExitContext {
        if self.has_exit_context() {
            match self.event.take() {
                ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(v)) => v,
                _ => panic!(),
            }
        } else {
            AlkanesExitContext::new()
        }
    }

    // .alkanes.AlkanesCreate create_alkane = 3;

    pub fn create_alkane(&self) -> &AlkanesCreate {
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(ref v)) => v,
            _ => <AlkanesCreate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_alkane(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_create_alkane(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_alkane(&mut self, v: AlkanesCreate) {
        self.event = ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_alkane(&mut self) -> &mut AlkanesCreate {
        if let ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(AlkanesCreate::new()));
        }
        match self.event {
            ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_alkane(&mut self) -> AlkanesCreate {
        if self.has_create_alkane() {
            match self.event.take() {
                ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(v)) => v,
                _ => panic!(),
            }
        } else {
            AlkanesCreate::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AlkanesEnterContext>(
            "enter_context",
            AlkanesTraceEvent::has_enter_context,
            AlkanesTraceEvent::enter_context,
            AlkanesTraceEvent::mut_enter_context,
            AlkanesTraceEvent::set_enter_context,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AlkanesExitContext>(
            "exit_context",
            AlkanesTraceEvent::has_exit_context,
            AlkanesTraceEvent::exit_context,
            AlkanesTraceEvent::mut_exit_context,
            AlkanesTraceEvent::set_exit_context,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AlkanesCreate>(
            "create_alkane",
            AlkanesTraceEvent::has_create_alkane,
            AlkanesTraceEvent::create_alkane,
            AlkanesTraceEvent::mut_create_alkane,
            AlkanesTraceEvent::set_create_alkane,
        ));
        oneofs.push(alkanes_trace_event::Event::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkanesTraceEvent>(
            "AlkanesTraceEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkanesTraceEvent {
    const NAME: &'static str = "AlkanesTraceEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event = ::std::option::Option::Some(alkanes_trace_event::Event::EnterContext(is.read_message()?));
                },
                18 => {
                    self.event = ::std::option::Option::Some(alkanes_trace_event::Event::ExitContext(is.read_message()?));
                },
                26 => {
                    self.event = ::std::option::Option::Some(alkanes_trace_event::Event::CreateAlkane(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &alkanes_trace_event::Event::EnterContext(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &alkanes_trace_event::Event::ExitContext(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &alkanes_trace_event::Event::CreateAlkane(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &alkanes_trace_event::Event::EnterContext(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &alkanes_trace_event::Event::ExitContext(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &alkanes_trace_event::Event::CreateAlkane(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkanesTraceEvent {
        AlkanesTraceEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkanesTraceEvent {
        static instance: AlkanesTraceEvent = AlkanesTraceEvent {
            event: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkanesTraceEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkanesTraceEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkanesTraceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkanesTraceEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AlkanesTraceEvent`
pub mod alkanes_trace_event {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:alkanes.AlkanesTraceEvent.event)
    pub enum Event {
        // @@protoc_insertion_point(oneof_field:alkanes.AlkanesTraceEvent.enter_context)
        EnterContext(super::AlkanesEnterContext),
        // @@protoc_insertion_point(oneof_field:alkanes.AlkanesTraceEvent.exit_context)
        ExitContext(super::AlkanesExitContext),
        // @@protoc_insertion_point(oneof_field:alkanes.AlkanesTraceEvent.create_alkane)
        CreateAlkane(super::AlkanesCreate),
    }

    impl ::protobuf::Oneof for Event {
    }

    impl ::protobuf::OneofFull for Event {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AlkanesTraceEvent as ::protobuf::MessageFull>::descriptor().oneof_by_name("event").unwrap()).clone()
        }
    }

    impl Event {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Event>("event")
        }
    }
}

// @@protoc_insertion_point(message:alkanes.AlkanesBlockEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkanesBlockEvent {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkanesBlockEvent.traces)
    pub traces: ::protobuf::MessageField<AlkanesTrace>,
    // @@protoc_insertion_point(field:alkanes.AlkanesBlockEvent.outpoint)
    pub outpoint: ::protobuf::MessageField<Outpoint>,
    // @@protoc_insertion_point(field:alkanes.AlkanesBlockEvent.txindex)
    pub txindex: u64,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkanesBlockEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkanesBlockEvent {
    fn default() -> &'a AlkanesBlockEvent {
        <AlkanesBlockEvent as ::protobuf::Message>::default_instance()
    }
}

impl AlkanesBlockEvent {
    pub fn new() -> AlkanesBlockEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkanesTrace>(
            "traces",
            |m: &AlkanesBlockEvent| { &m.traces },
            |m: &mut AlkanesBlockEvent| { &mut m.traces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Outpoint>(
            "outpoint",
            |m: &AlkanesBlockEvent| { &m.outpoint },
            |m: &mut AlkanesBlockEvent| { &mut m.outpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txindex",
            |m: &AlkanesBlockEvent| { &m.txindex },
            |m: &mut AlkanesBlockEvent| { &mut m.txindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkanesBlockEvent>(
            "AlkanesBlockEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkanesBlockEvent {
    const NAME: &'static str = "AlkanesBlockEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.traces)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.outpoint)?;
                },
                24 => {
                    self.txindex = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.traces.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.outpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.txindex != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.txindex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.traces.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.outpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.txindex != 0 {
            os.write_uint64(3, self.txindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkanesBlockEvent {
        AlkanesBlockEvent::new()
    }

    fn clear(&mut self) {
        self.traces.clear();
        self.outpoint.clear();
        self.txindex = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkanesBlockEvent {
        static instance: AlkanesBlockEvent = AlkanesBlockEvent {
            traces: ::protobuf::MessageField::none(),
            outpoint: ::protobuf::MessageField::none(),
            txindex: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkanesBlockEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkanesBlockEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkanesBlockEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkanesBlockEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkanesBlockTraceEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkanesBlockTraceEvent {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkanesBlockTraceEvent.events)
    pub events: ::std::vec::Vec<AlkanesBlockEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkanesBlockTraceEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkanesBlockTraceEvent {
    fn default() -> &'a AlkanesBlockTraceEvent {
        <AlkanesBlockTraceEvent as ::protobuf::Message>::default_instance()
    }
}

impl AlkanesBlockTraceEvent {
    pub fn new() -> AlkanesBlockTraceEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &AlkanesBlockTraceEvent| { &m.events },
            |m: &mut AlkanesBlockTraceEvent| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkanesBlockTraceEvent>(
            "AlkanesBlockTraceEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkanesBlockTraceEvent {
    const NAME: &'static str = "AlkanesBlockTraceEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkanesBlockTraceEvent {
        AlkanesBlockTraceEvent::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkanesBlockTraceEvent {
        static instance: AlkanesBlockTraceEvent = AlkanesBlockTraceEvent {
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkanesBlockTraceEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkanesBlockTraceEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkanesBlockTraceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkanesBlockTraceEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkanesTrace)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkanesTrace {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkanesTrace.events)
    pub events: ::std::vec::Vec<AlkanesTraceEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkanesTrace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkanesTrace {
    fn default() -> &'a AlkanesTrace {
        <AlkanesTrace as ::protobuf::Message>::default_instance()
    }
}

impl AlkanesTrace {
    pub fn new() -> AlkanesTrace {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &AlkanesTrace| { &m.events },
            |m: &mut AlkanesTrace| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkanesTrace>(
            "AlkanesTrace",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkanesTrace {
    const NAME: &'static str = "AlkanesTrace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkanesTrace {
        AlkanesTrace::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkanesTrace {
        static instance: AlkanesTrace = AlkanesTrace {
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkanesTrace {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkanesTrace").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkanesTrace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkanesTrace {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.SimulateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SimulateResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.SimulateResponse.execution)
    pub execution: ::protobuf::MessageField<ExtendedCallResponse>,
    // @@protoc_insertion_point(field:alkanes.SimulateResponse.gas_used)
    pub gas_used: u64,
    // @@protoc_insertion_point(field:alkanes.SimulateResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.SimulateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SimulateResponse {
    fn default() -> &'a SimulateResponse {
        <SimulateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SimulateResponse {
    pub fn new() -> SimulateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExtendedCallResponse>(
            "execution",
            |m: &SimulateResponse| { &m.execution },
            |m: &mut SimulateResponse| { &mut m.execution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &SimulateResponse| { &m.gas_used },
            |m: &mut SimulateResponse| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &SimulateResponse| { &m.error },
            |m: &mut SimulateResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SimulateResponse>(
            "SimulateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SimulateResponse {
    const NAME: &'static str = "SimulateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.execution)?;
                },
                16 => {
                    self.gas_used = is.read_uint64()?;
                },
                26 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.execution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.gas_used);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.execution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(2, self.gas_used)?;
        }
        if !self.error.is_empty() {
            os.write_string(3, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SimulateResponse {
        SimulateResponse::new()
    }

    fn clear(&mut self) {
        self.execution.clear();
        self.gas_used = 0;
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SimulateResponse {
        static instance: SimulateResponse = SimulateResponse {
            execution: ::protobuf::MessageField::none(),
            gas_used: 0,
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SimulateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SimulateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SimulateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SimulateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.MultiSimulateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiSimulateResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.MultiSimulateResponse.responses)
    pub responses: ::std::vec::Vec<SimulateResponse>,
    // @@protoc_insertion_point(field:alkanes.MultiSimulateResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.MultiSimulateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiSimulateResponse {
    fn default() -> &'a MultiSimulateResponse {
        <MultiSimulateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiSimulateResponse {
    pub fn new() -> MultiSimulateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "responses",
            |m: &MultiSimulateResponse| { &m.responses },
            |m: &mut MultiSimulateResponse| { &mut m.responses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &MultiSimulateResponse| { &m.error },
            |m: &mut MultiSimulateResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiSimulateResponse>(
            "MultiSimulateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiSimulateResponse {
    const NAME: &'static str = "MultiSimulateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.responses.push(is.read_message()?);
                },
                18 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.responses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiSimulateResponse {
        MultiSimulateResponse::new()
    }

    fn clear(&mut self) {
        self.responses.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiSimulateResponse {
        static instance: MultiSimulateResponse = MultiSimulateResponse {
            responses: ::std::vec::Vec::new(),
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiSimulateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiSimulateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiSimulateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiSimulateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneInventoryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneInventoryRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneInventoryRequest.id)
    pub id: ::protobuf::MessageField<AlkaneId>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneInventoryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneInventoryRequest {
    fn default() -> &'a AlkaneInventoryRequest {
        <AlkaneInventoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneInventoryRequest {
    pub fn new() -> AlkaneInventoryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "id",
            |m: &AlkaneInventoryRequest| { &m.id },
            |m: &mut AlkaneInventoryRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneInventoryRequest>(
            "AlkaneInventoryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneInventoryRequest {
    const NAME: &'static str = "AlkaneInventoryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneInventoryRequest {
        AlkaneInventoryRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneInventoryRequest {
        static instance: AlkaneInventoryRequest = AlkaneInventoryRequest {
            id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneInventoryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneInventoryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneInventoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneInventoryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneIdToOutpointRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneIdToOutpointRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneIdToOutpointRequest.id)
    pub id: ::protobuf::MessageField<AlkaneId>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneIdToOutpointRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneIdToOutpointRequest {
    fn default() -> &'a AlkaneIdToOutpointRequest {
        <AlkaneIdToOutpointRequest as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneIdToOutpointRequest {
    pub fn new() -> AlkaneIdToOutpointRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "id",
            |m: &AlkaneIdToOutpointRequest| { &m.id },
            |m: &mut AlkaneIdToOutpointRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneIdToOutpointRequest>(
            "AlkaneIdToOutpointRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneIdToOutpointRequest {
    const NAME: &'static str = "AlkaneIdToOutpointRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneIdToOutpointRequest {
        AlkaneIdToOutpointRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneIdToOutpointRequest {
        static instance: AlkaneIdToOutpointRequest = AlkaneIdToOutpointRequest {
            id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneIdToOutpointRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneIdToOutpointRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneIdToOutpointRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneIdToOutpointRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneInventoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneInventoryResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneInventoryResponse.alkanes)
    pub alkanes: ::std::vec::Vec<AlkaneTransfer>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneInventoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneInventoryResponse {
    fn default() -> &'a AlkaneInventoryResponse {
        <AlkaneInventoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneInventoryResponse {
    pub fn new() -> AlkaneInventoryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alkanes",
            |m: &AlkaneInventoryResponse| { &m.alkanes },
            |m: &mut AlkaneInventoryResponse| { &mut m.alkanes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneInventoryResponse>(
            "AlkaneInventoryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneInventoryResponse {
    const NAME: &'static str = "AlkaneInventoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.alkanes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.alkanes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.alkanes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneInventoryResponse {
        AlkaneInventoryResponse::new()
    }

    fn clear(&mut self) {
        self.alkanes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneInventoryResponse {
        static instance: AlkaneInventoryResponse = AlkaneInventoryResponse {
            alkanes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneInventoryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneInventoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneInventoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneInventoryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneStorageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneStorageRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneStorageRequest.id)
    pub id: ::protobuf::MessageField<AlkaneId>,
    // @@protoc_insertion_point(field:alkanes.AlkaneStorageRequest.path)
    pub path: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneStorageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneStorageRequest {
    fn default() -> &'a AlkaneStorageRequest {
        <AlkaneStorageRequest as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneStorageRequest {
    pub fn new() -> AlkaneStorageRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "id",
            |m: &AlkaneStorageRequest| { &m.id },
            |m: &mut AlkaneStorageRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &AlkaneStorageRequest| { &m.path },
            |m: &mut AlkaneStorageRequest| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneStorageRequest>(
            "AlkaneStorageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneStorageRequest {
    const NAME: &'static str = "AlkaneStorageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                18 => {
                    self.path = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.path.is_empty() {
            os.write_bytes(2, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneStorageRequest {
        AlkaneStorageRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneStorageRequest {
        static instance: AlkaneStorageRequest = AlkaneStorageRequest {
            id: ::protobuf::MessageField::none(),
            path: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneStorageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneStorageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneStorageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneStorageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneStorageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneStorageResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneStorageResponse.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneStorageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneStorageResponse {
    fn default() -> &'a AlkaneStorageResponse {
        <AlkaneStorageResponse as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneStorageResponse {
    pub fn new() -> AlkaneStorageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &AlkaneStorageResponse| { &m.value },
            |m: &mut AlkaneStorageResponse| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneStorageResponse>(
            "AlkaneStorageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneStorageResponse {
    const NAME: &'static str = "AlkaneStorageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneStorageResponse {
        AlkaneStorageResponse::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneStorageResponse {
        static instance: AlkaneStorageResponse = AlkaneStorageResponse {
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneStorageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneStorageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneStorageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneStorageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.AlkaneIdToOutpointResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlkaneIdToOutpointResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.AlkaneIdToOutpointResponse.txid)
    pub txid: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.AlkaneIdToOutpointResponse.vout)
    pub vout: u32,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.AlkaneIdToOutpointResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlkaneIdToOutpointResponse {
    fn default() -> &'a AlkaneIdToOutpointResponse {
        <AlkaneIdToOutpointResponse as ::protobuf::Message>::default_instance()
    }
}

impl AlkaneIdToOutpointResponse {
    pub fn new() -> AlkaneIdToOutpointResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txid",
            |m: &AlkaneIdToOutpointResponse| { &m.txid },
            |m: &mut AlkaneIdToOutpointResponse| { &mut m.txid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vout",
            |m: &AlkaneIdToOutpointResponse| { &m.vout },
            |m: &mut AlkaneIdToOutpointResponse| { &mut m.vout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlkaneIdToOutpointResponse>(
            "AlkaneIdToOutpointResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlkaneIdToOutpointResponse {
    const NAME: &'static str = "AlkaneIdToOutpointResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.txid = is.read_bytes()?;
                },
                16 => {
                    self.vout = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.vout != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.vout);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.vout != 0 {
            os.write_uint32(2, self.vout)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlkaneIdToOutpointResponse {
        AlkaneIdToOutpointResponse::new()
    }

    fn clear(&mut self) {
        self.txid.clear();
        self.vout = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlkaneIdToOutpointResponse {
        static instance: AlkaneIdToOutpointResponse = AlkaneIdToOutpointResponse {
            txid: ::std::vec::Vec::new(),
            vout: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlkaneIdToOutpointResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlkaneIdToOutpointResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlkaneIdToOutpointResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlkaneIdToOutpointResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.Outpoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Outpoint {
    // message fields
    // @@protoc_insertion_point(field:alkanes.Outpoint.txid)
    pub txid: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.Outpoint.vout)
    pub vout: u32,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.Outpoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Outpoint {
    fn default() -> &'a Outpoint {
        <Outpoint as ::protobuf::Message>::default_instance()
    }
}

impl Outpoint {
    pub fn new() -> Outpoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txid",
            |m: &Outpoint| { &m.txid },
            |m: &mut Outpoint| { &mut m.txid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vout",
            |m: &Outpoint| { &m.vout },
            |m: &mut Outpoint| { &mut m.vout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Outpoint>(
            "Outpoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Outpoint {
    const NAME: &'static str = "Outpoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.txid = is.read_bytes()?;
                },
                16 => {
                    self.vout = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.vout != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.vout);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.vout != 0 {
            os.write_uint32(2, self.vout)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Outpoint {
        Outpoint::new()
    }

    fn clear(&mut self) {
        self.txid.clear();
        self.vout = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Outpoint {
        static instance: Outpoint = Outpoint {
            txid: ::std::vec::Vec::new(),
            vout: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Outpoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Outpoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Outpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Outpoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.Trace)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Trace {
    // message fields
    // @@protoc_insertion_point(field:alkanes.Trace.outpoint)
    pub outpoint: ::protobuf::MessageField<Outpoint>,
    // @@protoc_insertion_point(field:alkanes.Trace.trace)
    pub trace: ::protobuf::MessageField<AlkanesTrace>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.Trace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Trace {
    fn default() -> &'a Trace {
        <Trace as ::protobuf::Message>::default_instance()
    }
}

impl Trace {
    pub fn new() -> Trace {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Outpoint>(
            "outpoint",
            |m: &Trace| { &m.outpoint },
            |m: &mut Trace| { &mut m.outpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkanesTrace>(
            "trace",
            |m: &Trace| { &m.trace },
            |m: &mut Trace| { &mut m.trace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Trace>(
            "Trace",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Trace {
    const NAME: &'static str = "Trace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.outpoint)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trace)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.outpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.outpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.trace.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Trace {
        Trace::new()
    }

    fn clear(&mut self) {
        self.outpoint.clear();
        self.trace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Trace {
        static instance: Trace = Trace {
            outpoint: ::protobuf::MessageField::none(),
            trace: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Trace {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Trace").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Trace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trace {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.TraceBlockRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TraceBlockRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.TraceBlockRequest.block)
    pub block: u64,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.TraceBlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TraceBlockRequest {
    fn default() -> &'a TraceBlockRequest {
        <TraceBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl TraceBlockRequest {
    pub fn new() -> TraceBlockRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block",
            |m: &TraceBlockRequest| { &m.block },
            |m: &mut TraceBlockRequest| { &mut m.block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TraceBlockRequest>(
            "TraceBlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TraceBlockRequest {
    const NAME: &'static str = "TraceBlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.block = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.block != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.block);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.block != 0 {
            os.write_uint64(1, self.block)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TraceBlockRequest {
        TraceBlockRequest::new()
    }

    fn clear(&mut self) {
        self.block = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TraceBlockRequest {
        static instance: TraceBlockRequest = TraceBlockRequest {
            block: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TraceBlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TraceBlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TraceBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TraceBlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.TraceBlockResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TraceBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.TraceBlockResponse.traces)
    pub traces: ::std::vec::Vec<Trace>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.TraceBlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TraceBlockResponse {
    fn default() -> &'a TraceBlockResponse {
        <TraceBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl TraceBlockResponse {
    pub fn new() -> TraceBlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "traces",
            |m: &TraceBlockResponse| { &m.traces },
            |m: &mut TraceBlockResponse| { &mut m.traces },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TraceBlockResponse>(
            "TraceBlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TraceBlockResponse {
    const NAME: &'static str = "TraceBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.traces.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.traces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.traces {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TraceBlockResponse {
        TraceBlockResponse::new()
    }

    fn clear(&mut self) {
        self.traces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TraceBlockResponse {
        static instance: TraceBlockResponse = TraceBlockResponse {
            traces: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TraceBlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TraceBlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TraceBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TraceBlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.BytecodeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BytecodeRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.BytecodeRequest.id)
    pub id: ::protobuf::MessageField<AlkaneId>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.BytecodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BytecodeRequest {
    fn default() -> &'a BytecodeRequest {
        <BytecodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl BytecodeRequest {
    pub fn new() -> BytecodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AlkaneId>(
            "id",
            |m: &BytecodeRequest| { &m.id },
            |m: &mut BytecodeRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BytecodeRequest>(
            "BytecodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BytecodeRequest {
    const NAME: &'static str = "BytecodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BytecodeRequest {
        BytecodeRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BytecodeRequest {
        static instance: BytecodeRequest = BytecodeRequest {
            id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BytecodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BytecodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BytecodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BytecodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.BlockRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.BlockRequest.height)
    pub height: u32,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.BlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockRequest {
    fn default() -> &'a BlockRequest {
        <BlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockRequest {
    pub fn new() -> BlockRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &BlockRequest| { &m.height },
            |m: &mut BlockRequest| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockRequest>(
            "BlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockRequest {
    const NAME: &'static str = "BlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_uint32(1, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockRequest {
        BlockRequest::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockRequest {
        static instance: BlockRequest = BlockRequest {
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.BlockResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.BlockResponse.block)
    pub block: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.BlockResponse.height)
    pub height: u32,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.BlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockResponse {
    fn default() -> &'a BlockResponse {
        <BlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockResponse {
    pub fn new() -> BlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block",
            |m: &BlockResponse| { &m.block },
            |m: &mut BlockResponse| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &BlockResponse| { &m.height },
            |m: &mut BlockResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockResponse>(
            "BlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockResponse {
    const NAME: &'static str = "BlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.block = is.read_bytes()?;
                },
                16 => {
                    self.height = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.block.is_empty() {
            os.write_bytes(1, &self.block)?;
        }
        if self.height != 0 {
            os.write_uint32(2, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockResponse {
        BlockResponse::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockResponse {
        static instance: BlockResponse = BlockResponse {
            block: ::std::vec::Vec::new(),
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.TransactionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TransactionRequest {
    // message fields
    // @@protoc_insertion_point(field:alkanes.TransactionRequest.txid)
    pub txid: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.TransactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionRequest {
    fn default() -> &'a TransactionRequest {
        <TransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransactionRequest {
    pub fn new() -> TransactionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txid",
            |m: &TransactionRequest| { &m.txid },
            |m: &mut TransactionRequest| { &mut m.txid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionRequest>(
            "TransactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionRequest {
    const NAME: &'static str = "TransactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.txid = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionRequest {
        TransactionRequest::new()
    }

    fn clear(&mut self) {
        self.txid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionRequest {
        static instance: TransactionRequest = TransactionRequest {
            txid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.TransactionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TransactionResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.TransactionResponse.transaction)
    pub transaction: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.TransactionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionResponse {
    fn default() -> &'a TransactionResponse {
        <TransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransactionResponse {
    pub fn new() -> TransactionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction",
            |m: &TransactionResponse| { &m.transaction },
            |m: &mut TransactionResponse| { &mut m.transaction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionResponse>(
            "TransactionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionResponse {
    const NAME: &'static str = "TransactionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transaction = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transaction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.transaction.is_empty() {
            os.write_bytes(1, &self.transaction)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionResponse {
        TransactionResponse::new()
    }

    fn clear(&mut self) {
        self.transaction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionResponse {
        static instance: TransactionResponse = TransactionResponse {
            transaction: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.Payment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Payment {
    // message fields
    // @@protoc_insertion_point(field:alkanes.Payment.spendable)
    pub spendable: ::protobuf::MessageField<Outpoint>,
    // @@protoc_insertion_point(field:alkanes.Payment.output)
    pub output: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:alkanes.Payment.fulfilled)
    pub fulfilled: bool,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.Payment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Payment {
    fn default() -> &'a Payment {
        <Payment as ::protobuf::Message>::default_instance()
    }
}

impl Payment {
    pub fn new() -> Payment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Outpoint>(
            "spendable",
            |m: &Payment| { &m.spendable },
            |m: &mut Payment| { &mut m.spendable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output",
            |m: &Payment| { &m.output },
            |m: &mut Payment| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fulfilled",
            |m: &Payment| { &m.fulfilled },
            |m: &mut Payment| { &mut m.fulfilled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Payment>(
            "Payment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Payment {
    const NAME: &'static str = "Payment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spendable)?;
                },
                18 => {
                    self.output = is.read_bytes()?;
                },
                24 => {
                    self.fulfilled = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spendable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.output);
        }
        if self.fulfilled != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spendable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.output.is_empty() {
            os.write_bytes(2, &self.output)?;
        }
        if self.fulfilled != false {
            os.write_bool(3, self.fulfilled)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Payment {
        Payment::new()
    }

    fn clear(&mut self) {
        self.spendable.clear();
        self.output.clear();
        self.fulfilled = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Payment {
        static instance: Payment = Payment {
            spendable: ::protobuf::MessageField::none(),
            output: ::std::vec::Vec::new(),
            fulfilled: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Payment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Payment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:alkanes.PendingUnwrapsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PendingUnwrapsResponse {
    // message fields
    // @@protoc_insertion_point(field:alkanes.PendingUnwrapsResponse.payments)
    pub payments: ::std::vec::Vec<Payment>,
    // special fields
    // @@protoc_insertion_point(special_field:alkanes.PendingUnwrapsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PendingUnwrapsResponse {
    fn default() -> &'a PendingUnwrapsResponse {
        <PendingUnwrapsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PendingUnwrapsResponse {
    pub fn new() -> PendingUnwrapsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "payments",
            |m: &PendingUnwrapsResponse| { &m.payments },
            |m: &mut PendingUnwrapsResponse| { &mut m.payments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PendingUnwrapsResponse>(
            "PendingUnwrapsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PendingUnwrapsResponse {
    const NAME: &'static str = "PendingUnwrapsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.payments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.payments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.payments {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PendingUnwrapsResponse {
        PendingUnwrapsResponse::new()
    }

    fn clear(&mut self) {
        self.payments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PendingUnwrapsResponse {
        static instance: PendingUnwrapsResponse = PendingUnwrapsResponse {
            payments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PendingUnwrapsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PendingUnwrapsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PendingUnwrapsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingUnwrapsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:alkanes.AlkanesTraceCallType)
pub enum AlkanesTraceCallType {
    // @@protoc_insertion_point(enum_value:alkanes.AlkanesTraceCallType.NONE)
    NONE = 0,
    // @@protoc_insertion_point(enum_value:alkanes.AlkanesTraceCallType.CALL)
    CALL = 1,
    // @@protoc_insertion_point(enum_value:alkanes.AlkanesTraceCallType.DELEGATECALL)
    DELEGATECALL = 2,
    // @@protoc_insertion_point(enum_value:alkanes.AlkanesTraceCallType.STATICCALL)
    STATICCALL = 3,
}

impl ::protobuf::Enum for AlkanesTraceCallType {
    const NAME: &'static str = "AlkanesTraceCallType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlkanesTraceCallType> {
        match value {
            0 => ::std::option::Option::Some(AlkanesTraceCallType::NONE),
            1 => ::std::option::Option::Some(AlkanesTraceCallType::CALL),
            2 => ::std::option::Option::Some(AlkanesTraceCallType::DELEGATECALL),
            3 => ::std::option::Option::Some(AlkanesTraceCallType::STATICCALL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AlkanesTraceCallType> {
        match str {
            "NONE" => ::std::option::Option::Some(AlkanesTraceCallType::NONE),
            "CALL" => ::std::option::Option::Some(AlkanesTraceCallType::CALL),
            "DELEGATECALL" => ::std::option::Option::Some(AlkanesTraceCallType::DELEGATECALL),
            "STATICCALL" => ::std::option::Option::Some(AlkanesTraceCallType::STATICCALL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AlkanesTraceCallType] = &[
        AlkanesTraceCallType::NONE,
        AlkanesTraceCallType::CALL,
        AlkanesTraceCallType::DELEGATECALL,
        AlkanesTraceCallType::STATICCALL,
    ];
}

impl ::protobuf::EnumFull for AlkanesTraceCallType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AlkanesTraceCallType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AlkanesTraceCallType {
    fn default() -> Self {
        AlkanesTraceCallType::NONE
    }
}

impl AlkanesTraceCallType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AlkanesTraceCallType>("AlkanesTraceCallType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:alkanes.AlkanesTraceStatusFlag)
pub enum AlkanesTraceStatusFlag {
    // @@protoc_insertion_point(enum_value:alkanes.AlkanesTraceStatusFlag.SUCCESS)
    SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:alkanes.AlkanesTraceStatusFlag.FAILURE)
    FAILURE = 1,
}

impl ::protobuf::Enum for AlkanesTraceStatusFlag {
    const NAME: &'static str = "AlkanesTraceStatusFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlkanesTraceStatusFlag> {
        match value {
            0 => ::std::option::Option::Some(AlkanesTraceStatusFlag::SUCCESS),
            1 => ::std::option::Option::Some(AlkanesTraceStatusFlag::FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AlkanesTraceStatusFlag> {
        match str {
            "SUCCESS" => ::std::option::Option::Some(AlkanesTraceStatusFlag::SUCCESS),
            "FAILURE" => ::std::option::Option::Some(AlkanesTraceStatusFlag::FAILURE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AlkanesTraceStatusFlag] = &[
        AlkanesTraceStatusFlag::SUCCESS,
        AlkanesTraceStatusFlag::FAILURE,
    ];
}

impl ::protobuf::EnumFull for AlkanesTraceStatusFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AlkanesTraceStatusFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AlkanesTraceStatusFlag {
    fn default() -> Self {
        AlkanesTraceStatusFlag::SUCCESS
    }
}

impl AlkanesTraceStatusFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AlkanesTraceStatusFlag>("AlkanesTraceStatusFlag")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\ralkanes.proto\x12\x07alkanes\")\n\x07uint128\x12\x0e\n\x02lo\x18\x01\
    \x20\x01(\x04R\x02lo\x12\x0e\n\x02hi\x18\x02\x20\x01(\x04R\x02hi\"T\n\
    \x08AlkaneId\x12&\n\x05block\x18\x01\x20\x01(\x0b2\x10.alkanes.uint128R\
    \x05block\x12\x20\n\x02tx\x18\x02\x20\x01(\x0b2\x10.alkanes.uint128R\x02\
    tx\"[\n\x0eAlkaneTransfer\x12!\n\x02id\x18\x01\x20\x01(\x0b2\x11.alkanes\
    .AlkaneIdR\x02id\x12&\n\x05value\x18\x02\x20\x01(\x0b2\x10.alkanes.uint1\
    28R\x05value\"O\n\x14MultiSimulateRequest\x127\n\x07parcels\x18\x01\x20\
    \x03(\x0b2\x1d.alkanes.MessageContextParcelR\x07parcels\"\xa4\x02\n\x14M\
    essageContextParcel\x121\n\x07alkanes\x18\x01\x20\x03(\x0b2\x17.alkanes.\
    AlkaneTransferR\x07alkanes\x12\x20\n\x0btransaction\x18\x02\x20\x01(\x0c\
    R\x0btransaction\x12\x14\n\x05block\x18\x03\x20\x01(\x0cR\x05block\x12\
    \x16\n\x06height\x18\x04\x20\x01(\x04R\x06height\x12\x18\n\x07txindex\
    \x18\x06\x20\x01(\rR\x07txindex\x12\x1a\n\x08calldata\x18\x05\x20\x01(\
    \x0cR\x08calldata\x12\x12\n\x04vout\x18\x07\x20\x01(\rR\x04vout\x12\x18\
    \n\x07pointer\x18\x08\x20\x01(\rR\x07pointer\x12%\n\x0erefund_pointer\
    \x18\t\x20\x01(\rR\rrefundPointer\"6\n\x0cKeyValuePair\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\
    \x05value\"\x8e\x01\n\x14ExtendedCallResponse\x121\n\x07alkanes\x18\x01\
    \x20\x03(\x0b2\x17.alkanes.AlkaneTransferR\x07alkanes\x12/\n\x07storage\
    \x18\x02\x20\x03(\x0b2\x15.alkanes.KeyValuePairR\x07storage\x12\x12\n\
    \x04data\x18\x03\x20\x01(\x0cR\x04data\"\xe1\x01\n\x07Context\x12)\n\x06\
    myself\x18\x01\x20\x01(\x0b2\x11.alkanes.AlkaneIdR\x06myself\x12)\n\x06c\
    aller\x18\x02\x20\x01(\x0b2\x11.alkanes.AlkaneIdR\x06caller\x12(\n\x06in\
    puts\x18\x03\x20\x03(\x0b2\x10.alkanes.uint128R\x06inputs\x12\x12\n\x04v\
    out\x18\x04\x20\x01(\rR\x04vout\x12B\n\x10incoming_alkanes\x18\x05\x20\
    \x03(\x0b2\x17.alkanes.AlkaneTransferR\x0fincomingAlkanes\"J\n\x0cTraceC\
    ontext\x12&\n\x05inner\x18\x01\x20\x01(\x0b2\x10.alkanes.ContextR\x05inn\
    er\x12\x12\n\x04fuel\x18\x02\x20\x01(\x04R\x04fuel\"\x82\x01\n\x13Alkane\
    sEnterContext\x12:\n\tcall_type\x18\x01\x20\x01(\x0e2\x1d.alkanes.Alkane\
    sTraceCallTypeR\x08callType\x12/\n\x07context\x18\x02\x20\x01(\x0b2\x15.\
    alkanes.TraceContextR\x07context\"\x88\x01\n\x12AlkanesExitContext\x127\
    \n\x06status\x18\x01\x20\x01(\x0e2\x1f.alkanes.AlkanesTraceStatusFlagR\
    \x06status\x129\n\x08response\x18\x02\x20\x01(\x0b2\x1d.alkanes.Extended\
    CallResponseR\x08response\"A\n\rAlkanesCreate\x120\n\nnew_alkane\x18\x01\
    \x20\x01(\x0b2\x11.alkanes.AlkaneIdR\tnewAlkane\"\xe2\x01\n\x11AlkanesTr\
    aceEvent\x12C\n\renter_context\x18\x01\x20\x01(\x0b2\x1c.alkanes.Alkanes\
    EnterContextH\0R\x0centerContext\x12@\n\x0cexit_context\x18\x02\x20\x01(\
    \x0b2\x1b.alkanes.AlkanesExitContextH\0R\x0bexitContext\x12=\n\rcreate_a\
    lkane\x18\x03\x20\x01(\x0b2\x16.alkanes.AlkanesCreateH\0R\x0ccreateAlkan\
    eB\x07\n\x05event\"\x8b\x01\n\x11AlkanesBlockEvent\x12-\n\x06traces\x18\
    \x01\x20\x01(\x0b2\x15.alkanes.AlkanesTraceR\x06traces\x12-\n\x08outpoin\
    t\x18\x02\x20\x01(\x0b2\x11.alkanes.OutpointR\x08outpoint\x12\x18\n\x07t\
    xindex\x18\x03\x20\x01(\x04R\x07txindex\"L\n\x16AlkanesBlockTraceEvent\
    \x122\n\x06events\x18\x01\x20\x03(\x0b2\x1a.alkanes.AlkanesBlockEventR\
    \x06events\"B\n\x0cAlkanesTrace\x122\n\x06events\x18\x01\x20\x03(\x0b2\
    \x1a.alkanes.AlkanesTraceEventR\x06events\"\x80\x01\n\x10SimulateRespons\
    e\x12;\n\texecution\x18\x01\x20\x01(\x0b2\x1d.alkanes.ExtendedCallRespon\
    seR\texecution\x12\x19\n\x08gas_used\x18\x02\x20\x01(\x04R\x07gasUsed\
    \x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\"f\n\x15MultiSimulateRe\
    sponse\x127\n\tresponses\x18\x01\x20\x03(\x0b2\x19.alkanes.SimulateRespo\
    nseR\tresponses\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\";\n\x16\
    AlkaneInventoryRequest\x12!\n\x02id\x18\x01\x20\x01(\x0b2\x11.alkanes.Al\
    kaneIdR\x02id\">\n\x19AlkaneIdToOutpointRequest\x12!\n\x02id\x18\x01\x20\
    \x01(\x0b2\x11.alkanes.AlkaneIdR\x02id\"L\n\x17AlkaneInventoryResponse\
    \x121\n\x07alkanes\x18\x01\x20\x03(\x0b2\x17.alkanes.AlkaneTransferR\x07\
    alkanes\"M\n\x14AlkaneStorageRequest\x12!\n\x02id\x18\x01\x20\x01(\x0b2\
    \x11.alkanes.AlkaneIdR\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\x0cR\x04\
    path\"-\n\x15AlkaneStorageResponse\x12\x14\n\x05value\x18\x01\x20\x01(\
    \x0cR\x05value\"D\n\x1aAlkaneIdToOutpointResponse\x12\x12\n\x04txid\x18\
    \x01\x20\x01(\x0cR\x04txid\x12\x12\n\x04vout\x18\x02\x20\x01(\rR\x04vout\
    \"2\n\x08Outpoint\x12\x12\n\x04txid\x18\x01\x20\x01(\x0cR\x04txid\x12\
    \x12\n\x04vout\x18\x02\x20\x01(\rR\x04vout\"c\n\x05Trace\x12-\n\x08outpo\
    int\x18\x01\x20\x01(\x0b2\x11.alkanes.OutpointR\x08outpoint\x12+\n\x05tr\
    ace\x18\x02\x20\x01(\x0b2\x15.alkanes.AlkanesTraceR\x05trace\")\n\x11Tra\
    ceBlockRequest\x12\x14\n\x05block\x18\x01\x20\x01(\x04R\x05block\"<\n\
    \x12TraceBlockResponse\x12&\n\x06traces\x18\x01\x20\x03(\x0b2\x0e.alkane\
    s.TraceR\x06traces\"4\n\x0fBytecodeRequest\x12!\n\x02id\x18\x01\x20\x01(\
    \x0b2\x11.alkanes.AlkaneIdR\x02id\"&\n\x0cBlockRequest\x12\x16\n\x06heig\
    ht\x18\x01\x20\x01(\rR\x06height\"=\n\rBlockResponse\x12\x14\n\x05block\
    \x18\x01\x20\x01(\x0cR\x05block\x12\x16\n\x06height\x18\x02\x20\x01(\rR\
    \x06height\"(\n\x12TransactionRequest\x12\x12\n\x04txid\x18\x01\x20\x01(\
    \x0cR\x04txid\"7\n\x13TransactionResponse\x12\x20\n\x0btransaction\x18\
    \x01\x20\x01(\x0cR\x0btransaction\"p\n\x07Payment\x12/\n\tspendable\x18\
    \x01\x20\x01(\x0b2\x11.alkanes.OutpointR\tspendable\x12\x16\n\x06output\
    \x18\x02\x20\x01(\x0cR\x06output\x12\x1c\n\tfulfilled\x18\x03\x20\x01(\
    \x08R\tfulfilled\"F\n\x16PendingUnwrapsResponse\x12,\n\x08payments\x18\
    \x01\x20\x03(\x0b2\x10.alkanes.PaymentR\x08payments*L\n\x14AlkanesTraceC\
    allType\x12\x08\n\x04NONE\x10\0\x12\x08\n\x04CALL\x10\x01\x12\x10\n\x0cD\
    ELEGATECALL\x10\x02\x12\x0e\n\nSTATICCALL\x10\x03*2\n\x16AlkanesTraceSta\
    tusFlag\x12\x0b\n\x07SUCCESS\x10\0\x12\x0b\n\x07FAILURE\x10\x01b\x06prot\
    o3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(35);
            messages.push(Uint128::generated_message_descriptor_data());
            messages.push(AlkaneId::generated_message_descriptor_data());
            messages.push(AlkaneTransfer::generated_message_descriptor_data());
            messages.push(MultiSimulateRequest::generated_message_descriptor_data());
            messages.push(MessageContextParcel::generated_message_descriptor_data());
            messages.push(KeyValuePair::generated_message_descriptor_data());
            messages.push(ExtendedCallResponse::generated_message_descriptor_data());
            messages.push(Context::generated_message_descriptor_data());
            messages.push(TraceContext::generated_message_descriptor_data());
            messages.push(AlkanesEnterContext::generated_message_descriptor_data());
            messages.push(AlkanesExitContext::generated_message_descriptor_data());
            messages.push(AlkanesCreate::generated_message_descriptor_data());
            messages.push(AlkanesTraceEvent::generated_message_descriptor_data());
            messages.push(AlkanesBlockEvent::generated_message_descriptor_data());
            messages.push(AlkanesBlockTraceEvent::generated_message_descriptor_data());
            messages.push(AlkanesTrace::generated_message_descriptor_data());
            messages.push(SimulateResponse::generated_message_descriptor_data());
            messages.push(MultiSimulateResponse::generated_message_descriptor_data());
            messages.push(AlkaneInventoryRequest::generated_message_descriptor_data());
            messages.push(AlkaneIdToOutpointRequest::generated_message_descriptor_data());
            messages.push(AlkaneInventoryResponse::generated_message_descriptor_data());
            messages.push(AlkaneStorageRequest::generated_message_descriptor_data());
            messages.push(AlkaneStorageResponse::generated_message_descriptor_data());
            messages.push(AlkaneIdToOutpointResponse::generated_message_descriptor_data());
            messages.push(Outpoint::generated_message_descriptor_data());
            messages.push(Trace::generated_message_descriptor_data());
            messages.push(TraceBlockRequest::generated_message_descriptor_data());
            messages.push(TraceBlockResponse::generated_message_descriptor_data());
            messages.push(BytecodeRequest::generated_message_descriptor_data());
            messages.push(BlockRequest::generated_message_descriptor_data());
            messages.push(BlockResponse::generated_message_descriptor_data());
            messages.push(TransactionRequest::generated_message_descriptor_data());
            messages.push(TransactionResponse::generated_message_descriptor_data());
            messages.push(Payment::generated_message_descriptor_data());
            messages.push(PendingUnwrapsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(AlkanesTraceCallType::generated_enum_descriptor_data());
            enums.push(AlkanesTraceStatusFlag::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
